/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#ifndef _PROP_ATTRIBUTE_ARG_H_RPCGEN
#define _PROP_ATTRIBUTE_ARG_H_RPCGEN

#include <config.h>
#include <util/vml/types.h>
#include <util/vml/vml.h>
#include <util/enum.h>
#include <util/defines.h>
CPS_START_NAMESPACE

CPS_END_NAMESPACE
#include <alg/lanc_arg.h>
CPS_START_NAMESPACE

enum AttrType {
	GENERIC_PROP_ATTR = 0,
	POINT_SOURCE_ATTR = 1,
	WALL_SOURCE_ATTR = 2,
	VOLUME_SOURCE_ATTR = 3,
	MOMENTUM_ATTR = 4,
	PROP_IO_ATTR = 5,
	GPARITY_FLAVOR_ATTR = 6,
	CG_ATTR = 7,
	GAUGE_FIX_ATTR = 8,
	MOM_COS_ATTR = 9,
	PROP_COMBINATION_ATTR = 10,
	GPARITY_OTHER_FLAV_PROP_ATTR = 11,
	GPARITY_COMPLEX_CONJ_SOURCE_PARTNER_PROP_ATTR = 12,
	TWISTED_BC_ATTR = 13,
	STORE_MIDPROP_ATTR = 14,
	A2A_ATTR = 15,
	DEFLATED_CG_ATTR = 16,
	ATTR_NONE = -1000
};
typedef enum AttrType AttrType;
extern struct vml_enum_map AttrType_map[];

enum PropagatorType {
	QPROPW_TYPE = 0,
	A2A_PROP_TYPE = 1,
};
typedef enum PropagatorType PropagatorType;
extern struct vml_enum_map PropagatorType_map[];


#include <util/vml/vml_templates.h>
struct GenericPropAttrArg {
	PropagatorType type;
	char *tag;
	Float mass;
	BndCndType bc[4];
	   static AttrType getType (  ) ;
	   GenericPropAttrArg clone (  ) ;
	   void deep_copy(const GenericPropAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct GenericPropAttrArg GenericPropAttrArg;
template<> struct rpc_deepcopy<GenericPropAttrArg>{
	static void doit(GenericPropAttrArg &into, GenericPropAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<GenericPropAttrArg>{
	static void doit(GenericPropAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct PointSourceAttrArg {
	int pos[4];
	   static AttrType getType (  ) ;
	   PointSourceAttrArg clone (  ) ;
	   void deep_copy(const PointSourceAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct PointSourceAttrArg PointSourceAttrArg;
template<> struct rpc_deepcopy<PointSourceAttrArg>{
	static void doit(PointSourceAttrArg &into, PointSourceAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<PointSourceAttrArg>{
	static void doit(PointSourceAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct WallSourceAttrArg {
	int t;
	   static AttrType getType (  ) ;
	   WallSourceAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct WallSourceAttrArg WallSourceAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<WallSourceAttrArg>{
	static void doit(WallSourceAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct VolumeSourceAttrArg {
	   static AttrType getType (  ) ;
	   VolumeSourceAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct VolumeSourceAttrArg VolumeSourceAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<VolumeSourceAttrArg>{
	static void doit(VolumeSourceAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct MomentumAttrArg {
	int p[3];
	   static AttrType getType (  ) ;
	   MomentumAttrArg clone (  ) ;
	   void deep_copy(const MomentumAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct MomentumAttrArg MomentumAttrArg;
template<> struct rpc_deepcopy<MomentumAttrArg>{
	static void doit(MomentumAttrArg &into, MomentumAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<MomentumAttrArg>{
	static void doit(MomentumAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct PropIOAttrArg {
	char *qio_filename;
	bool_t prop_on_disk;
	int save_to_disk;
	   static AttrType getType (  ) ;
	   PropIOAttrArg clone (  ) ;
	   void deep_copy(const PropIOAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct PropIOAttrArg PropIOAttrArg;
template<> struct rpc_deepcopy<PropIOAttrArg>{
	static void doit(PropIOAttrArg &into, PropIOAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<PropIOAttrArg>{
	static void doit(PropIOAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct GparityFlavorAttrArg {
	int flavor;
	   static AttrType getType (  ) ;
	   GparityFlavorAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct GparityFlavorAttrArg GparityFlavorAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<GparityFlavorAttrArg>{
	static void doit(GparityFlavorAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct CGAttrArg {
	int max_num_iter;
	Float stop_rsd;
	Float true_rsd;
	   static AttrType getType (  ) ;
	   CGAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct CGAttrArg CGAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<CGAttrArg>{
	static void doit(CGAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct GaugeFixAttrArg {
	int gauge_fix_src;
	int gauge_fix_snk;
	   static AttrType getType (  ) ;
	   GaugeFixAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct GaugeFixAttrArg GaugeFixAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<GaugeFixAttrArg>{
	static void doit(GaugeFixAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct MomCosAttrArg {
	   static AttrType getType (  ) ;
	   MomCosAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct MomCosAttrArg MomCosAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<MomCosAttrArg>{
	static void doit(MomCosAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct GparityOtherFlavPropAttrArg {
	char *tag;
	   static AttrType getType (  ) ;
	   GparityOtherFlavPropAttrArg clone (  ) ;
	   void deep_copy(const GparityOtherFlavPropAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct GparityOtherFlavPropAttrArg GparityOtherFlavPropAttrArg;
template<> struct rpc_deepcopy<GparityOtherFlavPropAttrArg>{
	static void doit(GparityOtherFlavPropAttrArg &into, GparityOtherFlavPropAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<GparityOtherFlavPropAttrArg>{
	static void doit(GparityOtherFlavPropAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct GparityComplexConjSourcePartnerPropAttrArg {
	char *tag;
	   static AttrType getType (  ) ;
	   GparityComplexConjSourcePartnerPropAttrArg clone (  ) ;
	   void deep_copy(const GparityComplexConjSourcePartnerPropAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct GparityComplexConjSourcePartnerPropAttrArg GparityComplexConjSourcePartnerPropAttrArg;
template<> struct rpc_deepcopy<GparityComplexConjSourcePartnerPropAttrArg>{
	static void doit(GparityComplexConjSourcePartnerPropAttrArg &into, GparityComplexConjSourcePartnerPropAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<GparityComplexConjSourcePartnerPropAttrArg>{
	static void doit(GparityComplexConjSourcePartnerPropAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct TwistedBcAttrArg {
	int theta[3];
	   static AttrType getType (  ) ;
	   TwistedBcAttrArg clone (  ) ;
	   void deep_copy(const TwistedBcAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct TwistedBcAttrArg TwistedBcAttrArg;
template<> struct rpc_deepcopy<TwistedBcAttrArg>{
	static void doit(TwistedBcAttrArg &into, TwistedBcAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<TwistedBcAttrArg>{
	static void doit(TwistedBcAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct StoreMidpropAttrArg {
	   static AttrType getType (  ) ;
	   StoreMidpropAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
};
typedef struct StoreMidpropAttrArg StoreMidpropAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<StoreMidpropAttrArg>{
	static void doit(StoreMidpropAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct A2AAttrArg {
	char *lanczos_tag;
	int nl;
	int nhits;
	RandomType rand_type;
	int src_width;
	int dilute_flavor;
	int do_gauge_fix;
	   static AttrType getType (  ) ;
	   A2AAttrArg clone (  ) ;
	   void deep_copy(const A2AAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct A2AAttrArg A2AAttrArg;
template<> struct rpc_deepcopy<A2AAttrArg>{
	static void doit(A2AAttrArg &into, A2AAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<A2AAttrArg>{
	static void doit(A2AAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct DeflatedCGAttrArg {
	char *lanczos_tag;
	   static AttrType getType (  ) ;
	   DeflatedCGAttrArg clone (  ) ;
	   void print(const std::string &prefix ="");
	   void deep_copy(const DeflatedCGAttrArg &rhs);
};
typedef struct DeflatedCGAttrArg DeflatedCGAttrArg;
#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<DeflatedCGAttrArg>{
	static void doit(DeflatedCGAttrArg const &what, const std::string &prefix="" );
};

template<> struct rpc_deepcopy<DeflatedCGAttrArg>{
	static void doit(DeflatedCGAttrArg &into, DeflatedCGAttrArg const &from);
};


enum PropCombination {
	A_PLUS_B = 0,
	A_MINUS_B = 1,
};
typedef enum PropCombination PropCombination;
extern struct vml_enum_map PropCombination_map[];


#include <util/vml/vml_templates.h>
struct PropCombinationAttrArg {
	char *prop_A;
	char *prop_B;
	PropCombination combination;
	   static AttrType getType (  ) ;
	   PropCombinationAttrArg clone (  ) ;
	   void deep_copy(const PropCombinationAttrArg &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct PropCombinationAttrArg PropCombinationAttrArg;
template<> struct rpc_deepcopy<PropCombinationAttrArg>{
	static void doit(PropCombinationAttrArg &into, PropCombinationAttrArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<PropCombinationAttrArg>{
	static void doit(PropCombinationAttrArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct AttributeContainer {
	AttrType type;
	union {
		GenericPropAttrArg generic_prop_attr;
		PointSourceAttrArg point_source_attr;
		WallSourceAttrArg wall_source_attr;
		VolumeSourceAttrArg volume_source_attr;
		MomentumAttrArg momentum_attr;
		PropIOAttrArg prop_io_attr;
		GparityFlavorAttrArg gparity_flavor_attr;
		CGAttrArg cg_attr;
		GaugeFixAttrArg gauge_fix_attr;
		MomCosAttrArg mom_cos_attr;
		PropCombinationAttrArg prop_combination_attr;
		GparityOtherFlavPropAttrArg gparity_other_flav_prop_attr;
		GparityComplexConjSourcePartnerPropAttrArg gparity_complex_conj_source_partner_prop_attr;
		TwistedBcAttrArg twisted_bc_attr;
		StoreMidpropAttrArg store_midprop_attr;
		A2AAttrArg a2a_attr;
		DeflatedCGAttrArg deflated_cg_attr;
	} AttributeContainer_u;
	   template <typename T> static AttrType type_map();
	   void deep_copy(const AttributeContainer &rhs);
	   void print(const std::string &prefix ="");
};
typedef struct AttributeContainer AttributeContainer;
template <typename T> AttrType AttributeContainer::type_map(){
//	 return -1000;
	 return ATTR_NONE;
}
template <> AttrType AttributeContainer::type_map<GenericPropAttrArg>();
template <> AttrType AttributeContainer::type_map<PointSourceAttrArg>();
template <> AttrType AttributeContainer::type_map<WallSourceAttrArg>();
template <> AttrType AttributeContainer::type_map<VolumeSourceAttrArg>();
template <> AttrType AttributeContainer::type_map<MomentumAttrArg>();
template <> AttrType AttributeContainer::type_map<PropIOAttrArg>();
template <> AttrType AttributeContainer::type_map<GparityFlavorAttrArg>();
template <> AttrType AttributeContainer::type_map<CGAttrArg>();
template <> AttrType AttributeContainer::type_map<GaugeFixAttrArg>();
template <> AttrType AttributeContainer::type_map<MomCosAttrArg>();
template <> AttrType AttributeContainer::type_map<PropCombinationAttrArg>();
template <> AttrType AttributeContainer::type_map<GparityOtherFlavPropAttrArg>();
template <> AttrType AttributeContainer::type_map<GparityComplexConjSourcePartnerPropAttrArg>();
template <> AttrType AttributeContainer::type_map<TwistedBcAttrArg>();
template <> AttrType AttributeContainer::type_map<StoreMidpropAttrArg>();
template <> AttrType AttributeContainer::type_map<A2AAttrArg>();
template <> AttrType AttributeContainer::type_map<DeflatedCGAttrArg>();
template<> struct rpc_deepcopy<AttributeContainer>{
	static void doit(AttributeContainer &into, AttributeContainer const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<AttributeContainer>{
	static void doit(AttributeContainer const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct VML;
class PropagatorArg {
public:
	 bool Encode(char *filename,char *instance);
	 bool Decode(char *filename,char *instance);
	 bool Vml(VML *vmls,char *instance);
	GenericPropAttrArg generics;
	struct {
		u_int attributes_len;
		AttributeContainer *attributes_val;
	} attributes;
	   ~PropagatorArg (  ) ;
	   void deep_copy(const PropagatorArg &rhs);
	   void print(const std::string &prefix ="");
};
template<> struct rpc_deepcopy<PropagatorArg>{
	static void doit(PropagatorArg &into, PropagatorArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<PropagatorArg>{
	static void doit(PropagatorArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct VML;
class LanczosContainerArg {
public:
	 bool Encode(char *filename,char *instance);
	 bool Decode(char *filename,char *instance);
	 bool Vml(VML *vmls,char *instance);
	char *tag;
	LancArg lanc_arg;
	int cg_max_iter;
	Float cg_residual;
	int cg_precon_5d;
	BfmSolverType solver;
	Float mobius_scale;
	BndCndType tbc;
	   void deep_copy(const LanczosContainerArg &rhs);
	   void print(const std::string &prefix ="");
};
template<> struct rpc_deepcopy<LanczosContainerArg>{
	static void doit(LanczosContainerArg &into, LanczosContainerArg const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<LanczosContainerArg>{
	static void doit(LanczosContainerArg const &what, const std::string &prefix="" );
};



#include <util/vml/vml_templates.h>
struct VML;
class JobPropagatorArgs {
public:
	 bool Encode(char *filename,char *instance);
	 bool Decode(char *filename,char *instance);
	 bool Vml(VML *vmls,char *instance);
	struct {
		u_int props_len;
		PropagatorArg *props_val;
	} props;
	struct {
		u_int lanczos_len;
		LanczosContainerArg *lanczos_val;
	} lanczos;
	   JobPropagatorArgs (  ) ;
	   ~JobPropagatorArgs (  ) ;
	   void deep_copy(const JobPropagatorArgs &rhs);
	   void print(const std::string &prefix ="");
};
template<> struct rpc_deepcopy<JobPropagatorArgs>{
	static void doit(JobPropagatorArgs &into, JobPropagatorArgs const &from);
};

#ifndef _USE_STDLIB
#error "Cannot generate rpc_print commands without the standard library"
#endif
template<> struct rpc_print<JobPropagatorArgs>{
	static void doit(JobPropagatorArgs const &what, const std::string &prefix="" );
};


/* the xdr functions */

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__STDC__) || defined(__cplusplus)
extern  bool_t vml_AttrType (VML *, char *instance, AttrType*);
extern  bool_t vml_PropagatorType (VML *, char *instance, PropagatorType*);
extern  bool_t vml_GenericPropAttrArg (VML *, char *instance, GenericPropAttrArg*);
extern  bool_t vml_PointSourceAttrArg (VML *, char *instance, PointSourceAttrArg*);
extern  bool_t vml_WallSourceAttrArg (VML *, char *instance, WallSourceAttrArg*);
extern  bool_t vml_VolumeSourceAttrArg (VML *, char *instance, VolumeSourceAttrArg*);
extern  bool_t vml_MomentumAttrArg (VML *, char *instance, MomentumAttrArg*);
extern  bool_t vml_PropIOAttrArg (VML *, char *instance, PropIOAttrArg*);
extern  bool_t vml_GparityFlavorAttrArg (VML *, char *instance, GparityFlavorAttrArg*);
extern  bool_t vml_CGAttrArg (VML *, char *instance, CGAttrArg*);
extern  bool_t vml_GaugeFixAttrArg (VML *, char *instance, GaugeFixAttrArg*);
extern  bool_t vml_MomCosAttrArg (VML *, char *instance, MomCosAttrArg*);
extern  bool_t vml_GparityOtherFlavPropAttrArg (VML *, char *instance, GparityOtherFlavPropAttrArg*);
extern  bool_t vml_GparityComplexConjSourcePartnerPropAttrArg (VML *, char *instance, GparityComplexConjSourcePartnerPropAttrArg*);
extern  bool_t vml_TwistedBcAttrArg (VML *, char *instance, TwistedBcAttrArg*);
extern  bool_t vml_StoreMidpropAttrArg (VML *, char *instance, StoreMidpropAttrArg*);
extern  bool_t vml_A2AAttrArg (VML *, char *instance, A2AAttrArg*);
extern  bool_t vml_DeflatedCGAttrArg (VML *, char *instance, DeflatedCGAttrArg*);
extern  bool_t vml_PropCombination (VML *, char *instance, PropCombination*);
extern  bool_t vml_PropCombinationAttrArg (VML *, char *instance, PropCombinationAttrArg*);
extern  bool_t vml_AttributeContainer (VML *, char *instance, AttributeContainer*);
extern  bool_t vml_PropagatorArg (VML *, char *instance, PropagatorArg*);
extern  bool_t vml_LanczosContainerArg (VML *, char *instance, LanczosContainerArg*);
extern  bool_t vml_JobPropagatorArgs (VML *, char *instance, JobPropagatorArgs*);

#else /* K&R C */
extern  bool_t vml_AttrType (VML *, char *instance, AttrType*);
extern  bool_t vml_PropagatorType (VML *, char *instance, PropagatorType*);
extern  bool_t vml_GenericPropAttrArg (VML *, char *instance, GenericPropAttrArg*);
extern  bool_t vml_PointSourceAttrArg (VML *, char *instance, PointSourceAttrArg*);
extern  bool_t vml_WallSourceAttrArg (VML *, char *instance, WallSourceAttrArg*);
extern  bool_t vml_VolumeSourceAttrArg (VML *, char *instance, VolumeSourceAttrArg*);
extern  bool_t vml_MomentumAttrArg (VML *, char *instance, MomentumAttrArg*);
extern  bool_t vml_PropIOAttrArg (VML *, char *instance, PropIOAttrArg*);
extern  bool_t vml_GparityFlavorAttrArg (VML *, char *instance, GparityFlavorAttrArg*);
extern  bool_t vml_CGAttrArg (VML *, char *instance, CGAttrArg*);
extern  bool_t vml_GaugeFixAttrArg (VML *, char *instance, GaugeFixAttrArg*);
extern  bool_t vml_MomCosAttrArg (VML *, char *instance, MomCosAttrArg*);
extern  bool_t vml_GparityOtherFlavPropAttrArg (VML *, char *instance, GparityOtherFlavPropAttrArg*);
extern  bool_t vml_GparityComplexConjSourcePartnerPropAttrArg (VML *, char *instance, GparityComplexConjSourcePartnerPropAttrArg*);
extern  bool_t vml_TwistedBcAttrArg (VML *, char *instance, TwistedBcAttrArg*);
extern  bool_t vml_StoreMidpropAttrArg (VML *, char *instance, StoreMidpropAttrArg*);
extern  bool_t vml_A2AAttrArg (VML *, char *instance, A2AAttrArg*);
extern  bool_t vml_DeflatedCGAttrArg (VML *, char *instance, DeflatedCGAttrArg*);
extern  bool_t vml_PropCombination (VML *, char *instance, PropCombination*);
extern  bool_t vml_PropCombinationAttrArg (VML *, char *instance, PropCombinationAttrArg*);
extern  bool_t vml_AttributeContainer (VML *, char *instance, AttributeContainer*);
extern  bool_t vml_PropagatorArg (VML *, char *instance, PropagatorArg*);
extern  bool_t vml_LanczosContainerArg (VML *, char *instance, LanczosContainerArg*);
extern  bool_t vml_JobPropagatorArgs (VML *, char *instance, JobPropagatorArgs*);

#endif /* K&R C */

#ifdef __cplusplus
}
#endif
CPS_END_NAMESPACE

#endif /* !_PROP_ATTRIBUTE_ARG_H_RPCGEN */
