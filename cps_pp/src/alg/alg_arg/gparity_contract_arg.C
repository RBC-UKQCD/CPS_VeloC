/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/gparity_contract_arg.h>
CPS_START_NAMESPACE

bool_t
vml_ContractionType (VML *vmls, char *name,ContractionType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,ContractionType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map ContractionType_map[] = {
	{"ContractionType","CONTRACTION_TYPE_LL_MESONS",CONTRACTION_TYPE_LL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_HL_MESONS",CONTRACTION_TYPE_HL_MESONS},
	{"ContractionType","CONTRACTION_TYPE_O_VV_P_AA",CONTRACTION_TYPE_O_VV_P_AA},
	{"ContractionType","CONTRACTION_TYPE_ALL_BILINEARS",CONTRACTION_TYPE_ALL_BILINEARS},
	{"ContractionType","CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM",CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM},
	{"ContractionType","CONTRACTION_TYPE_FOURIER_PROP",CONTRACTION_TYPE_FOURIER_PROP},
	{"ContractionType","CONTRACTION_TYPE_BILINEAR_VERTEX",CONTRACTION_TYPE_BILINEAR_VERTEX},
	{"ContractionType","CONTRACTION_TYPE_QUADRILINEAR_VERTEX",CONTRACTION_TYPE_QUADRILINEAR_VERTEX},
	{"ContractionType","CONTRACTION_TYPE_TOPOLOGICAL_CHARGE",CONTRACTION_TYPE_TOPOLOGICAL_CHARGE},
	{"ContractionType","CONTRACTION_TYPE_MRES",CONTRACTION_TYPE_MRES},
	{"ContractionType","CONTRACTION_TYPE_A2A_BILINEAR",CONTRACTION_TYPE_A2A_BILINEAR},
	{"ContractionType","CONTRACTION_TYPE_WILSON_FLOW",CONTRACTION_TYPE_WILSON_FLOW},
	{"ContractionType","CONTRACTION_TYPE_K_TO_PIPI",CONTRACTION_TYPE_K_TO_PIPI},
	{NULL,NULL,0}
};

bool_t
vml_ContractionTypeLLMesons (VML *vmls, char *name,ContractionTypeLLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeLLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeLLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeLLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeLLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeLLMesons>::doit(ContractionTypeLLMesons &into, ContractionTypeLLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeLLMesons::deep_copy(ContractionTypeLLMesons const &rhs){
	rpc_deepcopy<ContractionTypeLLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeHLMesons (VML *vmls, char *name,ContractionTypeHLMesons *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeHLMesons",name);
	int i;
	 if (!vml_string (vmls, "prop_H", &objp->prop_H, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_vector (vmls, "sink_mom", (char *)objp->sink_mom, 3,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeHLMesons",name);
	return TRUE;
}
void rpc_print<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H,strlen(what.prop_H)+1,spaces+" prop_H = ");
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	{
	  std::ostringstream os; os << spaces << " sink_mom[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " sink_mom["<<i<<"] = "; rpc_print<int>::doit(what.sink_mom[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeHLMesons::print(const std::string &prefix){
	rpc_print<ContractionTypeHLMesons>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeHLMesons>::doit(ContractionTypeHLMesons &into, ContractionTypeHLMesons const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H,from.prop_H,strlen(from.prop_H)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  for(int i=0;i<3;i++) rpc_deepcopy<int>::doit(into.sink_mom[i],from.sink_mom[i]);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeHLMesons::deep_copy(ContractionTypeHLMesons const &rhs){
	rpc_deepcopy<ContractionTypeHLMesons>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeOVVpAA (VML *vmls, char *name,ContractionTypeOVVpAA *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeOVVpAA",name);
	 if (!vml_string (vmls, "prop_H_t0", &objp->prop_H_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t0", &objp->prop_L_t0, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_H_t1", &objp->prop_H_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_L_t1", &objp->prop_L_t1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeOVVpAA",name);
	return TRUE;
}
void rpc_print<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_H_t0,strlen(what.prop_H_t0)+1,spaces+" prop_H_t0 = ");
	rpc_print<char *>::doit(what.prop_L_t0,strlen(what.prop_L_t0)+1,spaces+" prop_L_t0 = ");
	rpc_print<char *>::doit(what.prop_H_t1,strlen(what.prop_H_t1)+1,spaces+" prop_H_t1 = ");
	rpc_print<char *>::doit(what.prop_L_t1,strlen(what.prop_L_t1)+1,spaces+" prop_L_t1 = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeOVVpAA::print(const std::string &prefix){
	rpc_print<ContractionTypeOVVpAA>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeOVVpAA>::doit(ContractionTypeOVVpAA &into, ContractionTypeOVVpAA const &from){
	  rpc_deepcopy<char *>::doit(into.prop_H_t0,from.prop_H_t0,strlen(from.prop_H_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t0,from.prop_L_t0,strlen(from.prop_L_t0)+1);
	  rpc_deepcopy<char *>::doit(into.prop_H_t1,from.prop_H_t1,strlen(from.prop_H_t1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_L_t1,from.prop_L_t1,strlen(from.prop_L_t1)+1);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeOVVpAA::deep_copy(ContractionTypeOVVpAA const &rhs){
	rpc_deepcopy<ContractionTypeOVVpAA>::doit(*this,rhs);
}

bool_t
vml_MomArg (VML *vmls, char *name,MomArg *objp)
{
	 vml_struct_begin(vmls,"MomArg",name);
	int i;
	 if (!vml_vector (vmls, "p", (char *)objp->p, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_struct_end(vmls,"MomArg",name);
	return TRUE;
}
void rpc_print<MomArg>::doit(MomArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " p[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p["<<i<<"] = "; rpc_print<Float>::doit(what.p[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void MomArg::print(const std::string &prefix){
	rpc_print<MomArg>::doit(*this,prefix);
}
void rpc_deepcopy<MomArg>::doit(MomArg &into, MomArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p[i],from.p[i]);
}
void MomArg::deep_copy(MomArg const &rhs){
	rpc_deepcopy<MomArg>::doit(*this,rhs);
}

bool_t
vml_MomPairArg (VML *vmls, char *name,MomPairArg *objp)
{
	 vml_struct_begin(vmls,"MomPairArg",name);
	int i;
	 if (!vml_vector (vmls, "p1", (char *)objp->p1, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 if (!vml_vector (vmls, "p2", (char *)objp->p2, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 vml_struct_end(vmls,"MomPairArg",name);
	return TRUE;
}
void rpc_print<MomPairArg>::doit(MomPairArg const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	{
	  std::ostringstream os; os << spaces << " p1[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p1["<<i<<"] = "; rpc_print<Float>::doit(what.p1[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	{
	  std::ostringstream os; os << spaces << " p2[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p2["<<i<<"] = "; rpc_print<Float>::doit(what.p2[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	std::cout << spaces << "}\n";
}
void MomPairArg::print(const std::string &prefix){
	rpc_print<MomPairArg>::doit(*this,prefix);
}
void rpc_deepcopy<MomPairArg>::doit(MomPairArg &into, MomPairArg const &from){
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p1[i],from.p1[i]);
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p2[i],from.p2[i]);
}
void MomPairArg::deep_copy(MomPairArg const &rhs){
	rpc_deepcopy<MomPairArg>::doit(*this,rhs);
}

bool_t
vml_PropSuperscript (VML *vmls, char *name,PropSuperscript *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,PropSuperscript_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map PropSuperscript_map[] = {
	{"PropSuperscript","OpNone",OpNone},
	{"PropSuperscript","OpTranspose",OpTranspose},
	{"PropSuperscript","OpConj",OpConj},
	{"PropSuperscript","OpDagger",OpDagger},
	{"PropSuperscript","OpFlipMomentum",OpFlipMomentum},
	{"PropSuperscript","OpTransposeFlipMomentum",OpTransposeFlipMomentum},
	{"PropSuperscript","OpConjFlipMomentum",OpConjFlipMomentum},
	{"PropSuperscript","OpDaggerFlipMomentum",OpDaggerFlipMomentum},
	{NULL,NULL,0}
};

bool_t
vml_ContractionTypeAllBilinears (VML *vmls, char *name,ContractionTypeAllBilinears *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeAllBilinears",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_PropSuperscript (vmls, "op1", &objp->op1))
		 return FALSE;
	 if (!vml_PropSuperscript (vmls, "op2", &objp->op2))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeAllBilinears",name);
	return TRUE;
}
void rpc_print<ContractionTypeAllBilinears>::doit(ContractionTypeAllBilinears const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<PropSuperscript>::doit(what.op1,spaces+" op1 = ");
	rpc_print<PropSuperscript>::doit(what.op2,spaces+" op2 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeAllBilinears::print(const std::string &prefix){
	rpc_print<ContractionTypeAllBilinears>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeAllBilinears>::doit(ContractionTypeAllBilinears &into, ContractionTypeAllBilinears const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  rpc_deepcopy<PropSuperscript>::doit(into.op1,from.op1);
	  rpc_deepcopy<PropSuperscript>::doit(into.op2,from.op2);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeAllBilinears::deep_copy(ContractionTypeAllBilinears const &rhs){
	rpc_deepcopy<ContractionTypeAllBilinears>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeAllWallSinkBilinearsSpecificMomentum (VML *vmls, char *name,ContractionTypeAllWallSinkBilinearsSpecificMomentum *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeAllWallSinkBilinearsSpecificMomentum",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_PropSuperscript (vmls, "op1", &objp->op1))
		 return FALSE;
	 if (!vml_PropSuperscript (vmls, "op2", &objp->op2))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomPairArg), (vmlproc_t) vml_MomPairArg))
		 return FALSE;
	 if (!vml_int (vmls, "cosine_sink", &objp->cosine_sink))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeAllWallSinkBilinearsSpecificMomentum",name);
	return TRUE;
}
void rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(ContractionTypeAllWallSinkBilinearsSpecificMomentum const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<PropSuperscript>::doit(what.op1,spaces+" op1 = ");
	rpc_print<PropSuperscript>::doit(what.op2,spaces+" op2 = ");
	rpc_print<MomPairArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<int>::doit(what.cosine_sink,spaces+" cosine_sink = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeAllWallSinkBilinearsSpecificMomentum::print(const std::string &prefix){
	rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(ContractionTypeAllWallSinkBilinearsSpecificMomentum &into, ContractionTypeAllWallSinkBilinearsSpecificMomentum const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  rpc_deepcopy<PropSuperscript>::doit(into.op1,from.op1);
	  rpc_deepcopy<PropSuperscript>::doit(into.op2,from.op2);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomPairArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<int>::doit(into.cosine_sink,from.cosine_sink);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeAllWallSinkBilinearsSpecificMomentum::deep_copy(ContractionTypeAllWallSinkBilinearsSpecificMomentum const &rhs){
	rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeFourierProp (VML *vmls, char *name,ContractionTypeFourierProp *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeFourierProp",name);
	 if (!vml_string (vmls, "prop", &objp->prop, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "gauge_fix", &objp->gauge_fix))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeFourierProp",name);
	return TRUE;
}
void rpc_print<ContractionTypeFourierProp>::doit(ContractionTypeFourierProp const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop,strlen(what.prop)+1,spaces+" prop = ");
	rpc_print<int>::doit(what.gauge_fix,spaces+" gauge_fix = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeFourierProp::print(const std::string &prefix){
	rpc_print<ContractionTypeFourierProp>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeFourierProp>::doit(ContractionTypeFourierProp &into, ContractionTypeFourierProp const &from){
	  rpc_deepcopy<char *>::doit(into.prop,from.prop,strlen(from.prop)+1);
	  rpc_deepcopy<int>::doit(into.gauge_fix,from.gauge_fix);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeFourierProp::deep_copy(ContractionTypeFourierProp const &rhs){
	rpc_deepcopy<ContractionTypeFourierProp>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeBilinearVertex (VML *vmls, char *name,ContractionTypeBilinearVertex *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeBilinearVertex",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeBilinearVertex",name);
	return TRUE;
}
void rpc_print<ContractionTypeBilinearVertex>::doit(ContractionTypeBilinearVertex const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeBilinearVertex::print(const std::string &prefix){
	rpc_print<ContractionTypeBilinearVertex>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeBilinearVertex>::doit(ContractionTypeBilinearVertex &into, ContractionTypeBilinearVertex const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeBilinearVertex::deep_copy(ContractionTypeBilinearVertex const &rhs){
	rpc_deepcopy<ContractionTypeBilinearVertex>::doit(*this,rhs);
}

bool_t
vml_QuadrilinearSpinStructure (VML *vmls, char *name,QuadrilinearSpinStructure *objp)
{
	 vml_struct_begin(vmls,"QuadrilinearSpinStructure",name);
	 if (!vml_array (vmls, "Gamma1", (char **)&objp->Gamma1.Gamma1_val, (u_int *) &objp->Gamma1.Gamma1_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Gamma2", (char **)&objp->Gamma2.Gamma2_val, (u_int *) &objp->Gamma2.Gamma2_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Sigma1", (char **)&objp->Sigma1.Sigma1_val, (u_int *) &objp->Sigma1.Sigma1_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "Sigma2", (char **)&objp->Sigma2.Sigma2_val, (u_int *) &objp->Sigma2.Sigma2_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 vml_struct_end(vmls,"QuadrilinearSpinStructure",name);
	return TRUE;
}
void rpc_print<QuadrilinearSpinStructure>::doit(QuadrilinearSpinStructure const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int *>::doit(what.Gamma1.Gamma1_val,what.Gamma1.Gamma1_len,spaces+" Gamma1 = ");
	rpc_print<int *>::doit(what.Gamma2.Gamma2_val,what.Gamma2.Gamma2_len,spaces+" Gamma2 = ");
	rpc_print<int *>::doit(what.Sigma1.Sigma1_val,what.Sigma1.Sigma1_len,spaces+" Sigma1 = ");
	rpc_print<int *>::doit(what.Sigma2.Sigma2_val,what.Sigma2.Sigma2_len,spaces+" Sigma2 = ");
	std::cout << spaces << "}\n";
}
void QuadrilinearSpinStructure::print(const std::string &prefix){
	rpc_print<QuadrilinearSpinStructure>::doit(*this,prefix);
}

bool_t
vml_ContractionTypeQuadrilinearVertex (VML *vmls, char *name,ContractionTypeQuadrilinearVertex *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeQuadrilinearVertex",name);
	 if (!vml_string (vmls, "prop_1", &objp->prop_1, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_2", &objp->prop_2, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_3", &objp->prop_3, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_4", &objp->prop_4, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "momenta", (char **)&objp->momenta.momenta_val, (u_int *) &objp->momenta.momenta_len, ~0,
		sizeof (MomArg), (vmlproc_t) vml_MomArg))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 if (!vml_array (vmls, "spin_structs", (char **)&objp->spin_structs.spin_structs_val, (u_int *) &objp->spin_structs.spin_structs_len, ~0,
		sizeof (QuadrilinearSpinStructure), (vmlproc_t) vml_QuadrilinearSpinStructure))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeQuadrilinearVertex",name);
	return TRUE;
}
void rpc_print<ContractionTypeQuadrilinearVertex>::doit(ContractionTypeQuadrilinearVertex const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_1,strlen(what.prop_1)+1,spaces+" prop_1 = ");
	rpc_print<char *>::doit(what.prop_2,strlen(what.prop_2)+1,spaces+" prop_2 = ");
	rpc_print<char *>::doit(what.prop_3,strlen(what.prop_3)+1,spaces+" prop_3 = ");
	rpc_print<char *>::doit(what.prop_4,strlen(what.prop_4)+1,spaces+" prop_4 = ");
	rpc_print<MomArg *>::doit(what.momenta.momenta_val,what.momenta.momenta_len,spaces+" momenta = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	rpc_print<QuadrilinearSpinStructure *>::doit(what.spin_structs.spin_structs_val,what.spin_structs.spin_structs_len,spaces+" spin_structs = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeQuadrilinearVertex::print(const std::string &prefix){
	rpc_print<ContractionTypeQuadrilinearVertex>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(ContractionTypeQuadrilinearVertex &into, ContractionTypeQuadrilinearVertex const &from){
	  rpc_deepcopy<char *>::doit(into.prop_1,from.prop_1,strlen(from.prop_1)+1);
	  rpc_deepcopy<char *>::doit(into.prop_2,from.prop_2,strlen(from.prop_2)+1);
	  rpc_deepcopy<char *>::doit(into.prop_3,from.prop_3,strlen(from.prop_3)+1);
	  rpc_deepcopy<char *>::doit(into.prop_4,from.prop_4,strlen(from.prop_4)+1);
	  into.momenta.momenta_len = from.momenta.momenta_len;
	  rpc_deepcopy<MomArg *>::doit(into.momenta.momenta_val,from.momenta.momenta_val,from.momenta.momenta_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
	  into.spin_structs.spin_structs_len = from.spin_structs.spin_structs_len;
	  rpc_deepcopy<QuadrilinearSpinStructure *>::doit(into.spin_structs.spin_structs_val,from.spin_structs.spin_structs_val,from.spin_structs.spin_structs_len);
}
void ContractionTypeQuadrilinearVertex::deep_copy(ContractionTypeQuadrilinearVertex const &rhs){
	rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeTopologicalCharge (VML *vmls, char *name,ContractionTypeTopologicalCharge *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeTopologicalCharge",name);
	 if (!vml_int (vmls, "n_ape_smearing_cycles", &objp->n_ape_smearing_cycles))
		 return FALSE;
	 if (!vml_int (vmls, "ape_smear_su3_project", &objp->ape_smear_su3_project))
		 return FALSE;
	 if (!vml_Float (vmls, "ape_su3_proj_tolerance", &objp->ape_su3_proj_tolerance))
		 return FALSE;
	 if (!vml_int (vmls, "ape_orthog", &objp->ape_orthog))
		 return FALSE;
	 if (!vml_Float (vmls, "ape_coef", &objp->ape_coef))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeTopologicalCharge",name);
	return TRUE;
}
void rpc_print<ContractionTypeTopologicalCharge>::doit(ContractionTypeTopologicalCharge const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.n_ape_smearing_cycles,spaces+" n_ape_smearing_cycles = ");
	rpc_print<int>::doit(what.ape_smear_su3_project,spaces+" ape_smear_su3_project = ");
	rpc_print<Float>::doit(what.ape_su3_proj_tolerance,spaces+" ape_su3_proj_tolerance = ");
	rpc_print<int>::doit(what.ape_orthog,spaces+" ape_orthog = ");
	rpc_print<Float>::doit(what.ape_coef,spaces+" ape_coef = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeTopologicalCharge::print(const std::string &prefix){
	rpc_print<ContractionTypeTopologicalCharge>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(ContractionTypeTopologicalCharge &into, ContractionTypeTopologicalCharge const &from){
	  rpc_deepcopy<int>::doit(into.n_ape_smearing_cycles,from.n_ape_smearing_cycles);
	  rpc_deepcopy<int>::doit(into.ape_smear_su3_project,from.ape_smear_su3_project);
	  rpc_deepcopy<Float>::doit(into.ape_su3_proj_tolerance,from.ape_su3_proj_tolerance);
	  rpc_deepcopy<int>::doit(into.ape_orthog,from.ape_orthog);
	  rpc_deepcopy<Float>::doit(into.ape_coef,from.ape_coef);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeTopologicalCharge::deep_copy(ContractionTypeTopologicalCharge const &rhs){
	rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeMres (VML *vmls, char *name,ContractionTypeMres *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeMres",name);
	 if (!vml_string (vmls, "prop", &objp->prop, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeMres",name);
	return TRUE;
}
void rpc_print<ContractionTypeMres>::doit(ContractionTypeMres const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop,strlen(what.prop)+1,spaces+" prop = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeMres::print(const std::string &prefix){
	rpc_print<ContractionTypeMres>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeMres>::doit(ContractionTypeMres &into, ContractionTypeMres const &from){
	  rpc_deepcopy<char *>::doit(into.prop,from.prop,strlen(from.prop)+1);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeMres::deep_copy(ContractionTypeMres const &rhs){
	rpc_deepcopy<ContractionTypeMres>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeWilsonFlow (VML *vmls, char *name,ContractionTypeWilsonFlow *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeWilsonFlow",name);
	 if (!vml_int (vmls, "n_steps", &objp->n_steps))
		 return FALSE;
	 if (!vml_Float (vmls, "time_step", &objp->time_step))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeWilsonFlow",name);
	return TRUE;
}
void rpc_print<ContractionTypeWilsonFlow>::doit(ContractionTypeWilsonFlow const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.n_steps,spaces+" n_steps = ");
	rpc_print<Float>::doit(what.time_step,spaces+" time_step = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeWilsonFlow::print(const std::string &prefix){
	rpc_print<ContractionTypeWilsonFlow>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeWilsonFlow>::doit(ContractionTypeWilsonFlow &into, ContractionTypeWilsonFlow const &from){
	  rpc_deepcopy<int>::doit(into.n_steps,from.n_steps);
	  rpc_deepcopy<Float>::doit(into.time_step,from.time_step);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeWilsonFlow::deep_copy(ContractionTypeWilsonFlow const &rhs){
	rpc_deepcopy<ContractionTypeWilsonFlow>::doit(*this,rhs);
}

bool_t
vml_A2ASmearingType (VML *vmls, char *name,A2ASmearingType *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,A2ASmearingType_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map A2ASmearingType_map[] = {
	{"A2ASmearingType","BOX_3D_SMEARING",BOX_3D_SMEARING},
	{"A2ASmearingType","EXPONENTIAL_3D_SMEARING",EXPONENTIAL_3D_SMEARING},
	{NULL,NULL,0}
};

bool_t
vml_Box3dSmearing (VML *vmls, char *name,Box3dSmearing *objp)
{
	 vml_struct_begin(vmls,"Box3dSmearing",name);
	 if (!vml_int (vmls, "side_length", &objp->side_length))
		 return FALSE;
	 vml_struct_end(vmls,"Box3dSmearing",name);
	return TRUE;
}
void rpc_print<Box3dSmearing>::doit(Box3dSmearing const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.side_length,spaces+" side_length = ");
	std::cout << spaces << "}\n";
}
void Box3dSmearing::print(const std::string &prefix){
	rpc_print<Box3dSmearing>::doit(*this,prefix);
}

bool_t
vml_Exponential3dSmearing (VML *vmls, char *name,Exponential3dSmearing *objp)
{
	 vml_struct_begin(vmls,"Exponential3dSmearing",name);
	 if (!vml_Float (vmls, "radius", &objp->radius))
		 return FALSE;
	 vml_struct_end(vmls,"Exponential3dSmearing",name);
	return TRUE;
}
void rpc_print<Exponential3dSmearing>::doit(Exponential3dSmearing const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<Float>::doit(what.radius,spaces+" radius = ");
	std::cout << spaces << "}\n";
}
void Exponential3dSmearing::print(const std::string &prefix){
	rpc_print<Exponential3dSmearing>::doit(*this,prefix);
}

bool_t
vml_A2ASmearing (VML *vmls, char *name,A2ASmearing *objp)
{
	 if (!vml_A2ASmearingType (vmls, "type", &objp->type))
		 return FALSE;
	switch (objp->type) {
	case BOX_3D_SMEARING:
		 if (!vml_Box3dSmearing (vmls, "box_3d_smearing", &objp->A2ASmearing_u.box_3d_smearing))
			 return FALSE;
		break;
	case EXPONENTIAL_3D_SMEARING:
		 if (!vml_Exponential3dSmearing (vmls, "exponential_3d_smearing", &objp->A2ASmearing_u.exponential_3d_smearing))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
template <> A2ASmearingType A2ASmearing::type_map<Box3dSmearing>(){
	 return BOX_3D_SMEARING;
}
template <> A2ASmearingType A2ASmearing::type_map<Exponential3dSmearing>(){
	 return EXPONENTIAL_3D_SMEARING;
}
void rpc_deepcopy<A2ASmearing>::doit(A2ASmearing &into, A2ASmearing const &from){
	  into.type = from.type;
	  switch(from.type){
	    case BOX_3D_SMEARING:
	      rpc_deepcopy<Box3dSmearing>::doit(into.A2ASmearing_u.box_3d_smearing,from.A2ASmearing_u.box_3d_smearing); break;
	    case EXPONENTIAL_3D_SMEARING:
	      rpc_deepcopy<Exponential3dSmearing>::doit(into.A2ASmearing_u.exponential_3d_smearing,from.A2ASmearing_u.exponential_3d_smearing); break;
	  };
}
void A2ASmearing::deep_copy(A2ASmearing const &rhs){
	rpc_deepcopy<A2ASmearing>::doit(*this,rhs);
}
void rpc_print<A2ASmearing>::doit(A2ASmearing const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	  switch(what.type){
	    case BOX_3D_SMEARING:
	      rpc_print<Box3dSmearing>::doit(what.A2ASmearing_u.box_3d_smearing,spaces+" union A2ASmearing_u.box_3d_smearing = "); break;
	    case EXPONENTIAL_3D_SMEARING:
	      rpc_print<Exponential3dSmearing>::doit(what.A2ASmearing_u.exponential_3d_smearing,spaces+" union A2ASmearing_u.exponential_3d_smearing = "); break;
	  };
	std::cout << spaces << "}\n";
}
void A2ASmearing::print(const std::string &prefix){
	rpc_print<A2ASmearing>::doit(*this,prefix);
}

bool_t
vml_MatIdxAndCoeff (VML *vmls, char *name,MatIdxAndCoeff *objp)
{
	 vml_struct_begin(vmls,"MatIdxAndCoeff",name);
	 if (!vml_int (vmls, "idx", &objp->idx))
		 return FALSE;
	 if (!vml_Float (vmls, "coeff", &objp->coeff))
		 return FALSE;
	 vml_struct_end(vmls,"MatIdxAndCoeff",name);
	return TRUE;
}
void rpc_print<MatIdxAndCoeff>::doit(MatIdxAndCoeff const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<int>::doit(what.idx,spaces+" idx = ");
	rpc_print<Float>::doit(what.coeff,spaces+" coeff = ");
	std::cout << spaces << "}\n";
}
void MatIdxAndCoeff::print(const std::string &prefix){
	rpc_print<MatIdxAndCoeff>::doit(*this,prefix);
}

bool_t
vml_ContractionTypeA2ABilinear (VML *vmls, char *name,ContractionTypeA2ABilinear *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeA2ABilinear",name);
	 if (!vml_string (vmls, "prop_src_snk", &objp->prop_src_snk, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_snk_src", &objp->prop_snk_src, ~0))
		 return FALSE;
	 if (!vml_A2ASmearing (vmls, "source_smearing", &objp->source_smearing))
		 return FALSE;
	 if (!vml_A2ASmearing (vmls, "sink_smearing", &objp->sink_smearing))
		 return FALSE;
	 if (!vml_array (vmls, "source_spin_matrix", (char **)&objp->source_spin_matrix.source_spin_matrix_val, (u_int *) &objp->source_spin_matrix.source_spin_matrix_len, ~0,
		sizeof (MatIdxAndCoeff), (vmlproc_t) vml_MatIdxAndCoeff))
		 return FALSE;
	 if (!vml_array (vmls, "sink_spin_matrix", (char **)&objp->sink_spin_matrix.sink_spin_matrix_val, (u_int *) &objp->sink_spin_matrix.sink_spin_matrix_len, ~0,
		sizeof (MatIdxAndCoeff), (vmlproc_t) vml_MatIdxAndCoeff))
		 return FALSE;
	 if (!vml_array (vmls, "source_flavor_matrix", (char **)&objp->source_flavor_matrix.source_flavor_matrix_val, (u_int *) &objp->source_flavor_matrix.source_flavor_matrix_len, ~0,
		sizeof (MatIdxAndCoeff), (vmlproc_t) vml_MatIdxAndCoeff))
		 return FALSE;
	 if (!vml_array (vmls, "sink_flavor_matrix", (char **)&objp->sink_flavor_matrix.sink_flavor_matrix_val, (u_int *) &objp->sink_flavor_matrix.sink_flavor_matrix_len, ~0,
		sizeof (MatIdxAndCoeff), (vmlproc_t) vml_MatIdxAndCoeff))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeA2ABilinear",name);
	return TRUE;
}
void rpc_print<ContractionTypeA2ABilinear>::doit(ContractionTypeA2ABilinear const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_src_snk,strlen(what.prop_src_snk)+1,spaces+" prop_src_snk = ");
	rpc_print<char *>::doit(what.prop_snk_src,strlen(what.prop_snk_src)+1,spaces+" prop_snk_src = ");
	rpc_print<A2ASmearing>::doit(what.source_smearing,spaces+" source_smearing = ");
	rpc_print<A2ASmearing>::doit(what.sink_smearing,spaces+" sink_smearing = ");
	rpc_print<MatIdxAndCoeff *>::doit(what.source_spin_matrix.source_spin_matrix_val,what.source_spin_matrix.source_spin_matrix_len,spaces+" source_spin_matrix = ");
	rpc_print<MatIdxAndCoeff *>::doit(what.sink_spin_matrix.sink_spin_matrix_val,what.sink_spin_matrix.sink_spin_matrix_len,spaces+" sink_spin_matrix = ");
	rpc_print<MatIdxAndCoeff *>::doit(what.source_flavor_matrix.source_flavor_matrix_val,what.source_flavor_matrix.source_flavor_matrix_len,spaces+" source_flavor_matrix = ");
	rpc_print<MatIdxAndCoeff *>::doit(what.sink_flavor_matrix.sink_flavor_matrix_val,what.sink_flavor_matrix.sink_flavor_matrix_len,spaces+" sink_flavor_matrix = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeA2ABilinear::print(const std::string &prefix){
	rpc_print<ContractionTypeA2ABilinear>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeA2ABilinear>::doit(ContractionTypeA2ABilinear &into, ContractionTypeA2ABilinear const &from){
	  rpc_deepcopy<char *>::doit(into.prop_src_snk,from.prop_src_snk,strlen(from.prop_src_snk)+1);
	  rpc_deepcopy<char *>::doit(into.prop_snk_src,from.prop_snk_src,strlen(from.prop_snk_src)+1);
	  rpc_deepcopy<A2ASmearing>::doit(into.source_smearing,from.source_smearing);
	  rpc_deepcopy<A2ASmearing>::doit(into.sink_smearing,from.sink_smearing);
	  into.source_spin_matrix.source_spin_matrix_len = from.source_spin_matrix.source_spin_matrix_len;
	  rpc_deepcopy<MatIdxAndCoeff *>::doit(into.source_spin_matrix.source_spin_matrix_val,from.source_spin_matrix.source_spin_matrix_val,from.source_spin_matrix.source_spin_matrix_len);
	  into.sink_spin_matrix.sink_spin_matrix_len = from.sink_spin_matrix.sink_spin_matrix_len;
	  rpc_deepcopy<MatIdxAndCoeff *>::doit(into.sink_spin_matrix.sink_spin_matrix_val,from.sink_spin_matrix.sink_spin_matrix_val,from.sink_spin_matrix.sink_spin_matrix_len);
	  into.source_flavor_matrix.source_flavor_matrix_len = from.source_flavor_matrix.source_flavor_matrix_len;
	  rpc_deepcopy<MatIdxAndCoeff *>::doit(into.source_flavor_matrix.source_flavor_matrix_val,from.source_flavor_matrix.source_flavor_matrix_val,from.source_flavor_matrix.source_flavor_matrix_len);
	  into.sink_flavor_matrix.sink_flavor_matrix_len = from.sink_flavor_matrix.sink_flavor_matrix_len;
	  rpc_deepcopy<MatIdxAndCoeff *>::doit(into.sink_flavor_matrix.sink_flavor_matrix_val,from.sink_flavor_matrix.sink_flavor_matrix_val,from.sink_flavor_matrix.sink_flavor_matrix_len);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeA2ABilinear::deep_copy(ContractionTypeA2ABilinear const &rhs){
	rpc_deepcopy<ContractionTypeA2ABilinear>::doit(*this,rhs);
}

bool_t
vml_ContractionTypeKtoPiPi (VML *vmls, char *name,ContractionTypeKtoPiPi *objp)
{
	 vml_struct_begin(vmls,"ContractionTypeKtoPiPi",name);
	int i;
	 if (!vml_string (vmls, "prop_L", &objp->prop_L, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "prop_H", &objp->prop_H, ~0))
		 return FALSE;
	 if (!vml_MomPairArg (vmls, "p_qpi1", &objp->p_qpi1))
		 return FALSE;
	 if (!vml_MomPairArg (vmls, "p_qpi2", &objp->p_qpi2))
		 return FALSE;
	 if (!vml_vector (vmls, "p_qK", (char *)objp->p_qK, 3,
		sizeof (Float), (vmlproc_t) vml_Float))
		 return FALSE;
	 if (!vml_int (vmls, "gparity_use_transconv_props", &objp->gparity_use_transconv_props))
		 return FALSE;
	 if (!vml_A2ASmearing (vmls, "pion_source", &objp->pion_source))
		 return FALSE;
	 if (!vml_A2ASmearing (vmls, "kaon_source", &objp->kaon_source))
		 return FALSE;
	 if (!vml_int (vmls, "t_sep_pi_k", &objp->t_sep_pi_k))
		 return FALSE;
	 if (!vml_int (vmls, "t_sep_pion", &objp->t_sep_pion))
		 return FALSE;
	 if (!vml_string (vmls, "file", &objp->file, ~0))
		 return FALSE;
	 vml_struct_end(vmls,"ContractionTypeKtoPiPi",name);
	return TRUE;
}
void rpc_print<ContractionTypeKtoPiPi>::doit(ContractionTypeKtoPiPi const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	rpc_print<char *>::doit(what.prop_L,strlen(what.prop_L)+1,spaces+" prop_L = ");
	rpc_print<char *>::doit(what.prop_H,strlen(what.prop_H)+1,spaces+" prop_H = ");
	rpc_print<MomPairArg>::doit(what.p_qpi1,spaces+" p_qpi1 = ");
	rpc_print<MomPairArg>::doit(what.p_qpi2,spaces+" p_qpi2 = ");
	{
	  std::ostringstream os; os << spaces << " p_qK[3] = { ";
	  std::string newprefix = os.str(); std::string newspaces(newprefix.size(),' ');
	  std::cout << newprefix << std::endl;
	  for(int i=0;i<3;i++){ std::ostringstream tos; tos << newspaces << " p_qK["<<i<<"] = "; rpc_print<Float>::doit(what.p_qK[i],tos.str()); }
	  newspaces[newspaces.size()-1] = '}'; std::cout << newspaces << std::endl;
	}
	rpc_print<int>::doit(what.gparity_use_transconv_props,spaces+" gparity_use_transconv_props = ");
	rpc_print<A2ASmearing>::doit(what.pion_source,spaces+" pion_source = ");
	rpc_print<A2ASmearing>::doit(what.kaon_source,spaces+" kaon_source = ");
	rpc_print<int>::doit(what.t_sep_pi_k,spaces+" t_sep_pi_k = ");
	rpc_print<int>::doit(what.t_sep_pion,spaces+" t_sep_pion = ");
	rpc_print<char *>::doit(what.file,strlen(what.file)+1,spaces+" file = ");
	std::cout << spaces << "}\n";
}
void ContractionTypeKtoPiPi::print(const std::string &prefix){
	rpc_print<ContractionTypeKtoPiPi>::doit(*this,prefix);
}
void rpc_deepcopy<ContractionTypeKtoPiPi>::doit(ContractionTypeKtoPiPi &into, ContractionTypeKtoPiPi const &from){
	  rpc_deepcopy<char *>::doit(into.prop_L,from.prop_L,strlen(from.prop_L)+1);
	  rpc_deepcopy<char *>::doit(into.prop_H,from.prop_H,strlen(from.prop_H)+1);
	  rpc_deepcopy<MomPairArg>::doit(into.p_qpi1,from.p_qpi1);
	  rpc_deepcopy<MomPairArg>::doit(into.p_qpi2,from.p_qpi2);
	  for(int i=0;i<3;i++) rpc_deepcopy<Float>::doit(into.p_qK[i],from.p_qK[i]);
	  rpc_deepcopy<int>::doit(into.gparity_use_transconv_props,from.gparity_use_transconv_props);
	  rpc_deepcopy<A2ASmearing>::doit(into.pion_source,from.pion_source);
	  rpc_deepcopy<A2ASmearing>::doit(into.kaon_source,from.kaon_source);
	  rpc_deepcopy<int>::doit(into.t_sep_pi_k,from.t_sep_pi_k);
	  rpc_deepcopy<int>::doit(into.t_sep_pion,from.t_sep_pion);
	  rpc_deepcopy<char *>::doit(into.file,from.file,strlen(from.file)+1);
}
void ContractionTypeKtoPiPi::deep_copy(ContractionTypeKtoPiPi const &rhs){
	rpc_deepcopy<ContractionTypeKtoPiPi>::doit(*this,rhs);
}

bool_t
vml_GparityMeasurement (VML *vmls, char *name,GparityMeasurement *objp)
{
	 if (!vml_ContractionType (vmls, "type", &objp->type))
		 return FALSE;
	switch (objp->type) {
	case CONTRACTION_TYPE_LL_MESONS:
		 if (!vml_ContractionTypeLLMesons (vmls, "contraction_type_ll_mesons", &objp->GparityMeasurement_u.contraction_type_ll_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_HL_MESONS:
		 if (!vml_ContractionTypeHLMesons (vmls, "contraction_type_hl_mesons", &objp->GparityMeasurement_u.contraction_type_hl_mesons))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_O_VV_P_AA:
		 if (!vml_ContractionTypeOVVpAA (vmls, "contraction_type_o_vv_p_aa", &objp->GparityMeasurement_u.contraction_type_o_vv_p_aa))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_ALL_BILINEARS:
		 if (!vml_ContractionTypeAllBilinears (vmls, "contraction_type_all_bilinears", &objp->GparityMeasurement_u.contraction_type_all_bilinears))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
		 if (!vml_ContractionTypeAllWallSinkBilinearsSpecificMomentum (vmls, "contraction_type_all_wallsink_bilinears_specific_momentum", &objp->GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_FOURIER_PROP:
		 if (!vml_ContractionTypeFourierProp (vmls, "contraction_type_fourier_prop", &objp->GparityMeasurement_u.contraction_type_fourier_prop))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_BILINEAR_VERTEX:
		 if (!vml_ContractionTypeBilinearVertex (vmls, "contraction_type_bilinear_vertex", &objp->GparityMeasurement_u.contraction_type_bilinear_vertex))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
		 if (!vml_ContractionTypeQuadrilinearVertex (vmls, "contraction_type_quadrilinear_vertex", &objp->GparityMeasurement_u.contraction_type_quadrilinear_vertex))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
		 if (!vml_ContractionTypeTopologicalCharge (vmls, "contraction_type_topological_charge", &objp->GparityMeasurement_u.contraction_type_topological_charge))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_MRES:
		 if (!vml_ContractionTypeMres (vmls, "contraction_type_mres", &objp->GparityMeasurement_u.contraction_type_mres))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_A2A_BILINEAR:
		 if (!vml_ContractionTypeA2ABilinear (vmls, "contraction_type_a2a_bilinear", &objp->GparityMeasurement_u.contraction_type_a2a_bilinear))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_WILSON_FLOW:
		 if (!vml_ContractionTypeWilsonFlow (vmls, "contraction_type_wilson_flow", &objp->GparityMeasurement_u.contraction_type_wilson_flow))
			 return FALSE;
		break;
	case CONTRACTION_TYPE_K_TO_PIPI:
		 if (!vml_ContractionTypeKtoPiPi (vmls, "contraction_type_k_to_pipi", &objp->GparityMeasurement_u.contraction_type_k_to_pipi))
			 return FALSE;
		break;
	default:
		return FALSE;
	}
	return TRUE;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeLLMesons>(){
	 return CONTRACTION_TYPE_LL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeHLMesons>(){
	 return CONTRACTION_TYPE_HL_MESONS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeOVVpAA>(){
	 return CONTRACTION_TYPE_O_VV_P_AA;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeAllBilinears>(){
	 return CONTRACTION_TYPE_ALL_BILINEARS;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeAllWallSinkBilinearsSpecificMomentum>(){
	 return CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeFourierProp>(){
	 return CONTRACTION_TYPE_FOURIER_PROP;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeBilinearVertex>(){
	 return CONTRACTION_TYPE_BILINEAR_VERTEX;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeQuadrilinearVertex>(){
	 return CONTRACTION_TYPE_QUADRILINEAR_VERTEX;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeTopologicalCharge>(){
	 return CONTRACTION_TYPE_TOPOLOGICAL_CHARGE;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeMres>(){
	 return CONTRACTION_TYPE_MRES;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeA2ABilinear>(){
	 return CONTRACTION_TYPE_A2A_BILINEAR;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeWilsonFlow>(){
	 return CONTRACTION_TYPE_WILSON_FLOW;
}
template <> ContractionType GparityMeasurement::type_map<ContractionTypeKtoPiPi>(){
	 return CONTRACTION_TYPE_K_TO_PIPI;
}
void rpc_deepcopy<GparityMeasurement>::doit(GparityMeasurement &into, GparityMeasurement const &from){
	  into.type = from.type;
	  switch(from.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_deepcopy<ContractionTypeLLMesons>::doit(into.GparityMeasurement_u.contraction_type_ll_mesons,from.GparityMeasurement_u.contraction_type_ll_mesons); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_deepcopy<ContractionTypeHLMesons>::doit(into.GparityMeasurement_u.contraction_type_hl_mesons,from.GparityMeasurement_u.contraction_type_hl_mesons); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_deepcopy<ContractionTypeOVVpAA>::doit(into.GparityMeasurement_u.contraction_type_o_vv_p_aa,from.GparityMeasurement_u.contraction_type_o_vv_p_aa); break;
	    case CONTRACTION_TYPE_ALL_BILINEARS:
	      rpc_deepcopy<ContractionTypeAllBilinears>::doit(into.GparityMeasurement_u.contraction_type_all_bilinears,from.GparityMeasurement_u.contraction_type_all_bilinears); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
	      rpc_deepcopy<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(into.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum,from.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum); break;
	    case CONTRACTION_TYPE_FOURIER_PROP:
	      rpc_deepcopy<ContractionTypeFourierProp>::doit(into.GparityMeasurement_u.contraction_type_fourier_prop,from.GparityMeasurement_u.contraction_type_fourier_prop); break;
	    case CONTRACTION_TYPE_BILINEAR_VERTEX:
	      rpc_deepcopy<ContractionTypeBilinearVertex>::doit(into.GparityMeasurement_u.contraction_type_bilinear_vertex,from.GparityMeasurement_u.contraction_type_bilinear_vertex); break;
	    case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
	      rpc_deepcopy<ContractionTypeQuadrilinearVertex>::doit(into.GparityMeasurement_u.contraction_type_quadrilinear_vertex,from.GparityMeasurement_u.contraction_type_quadrilinear_vertex); break;
	    case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
	      rpc_deepcopy<ContractionTypeTopologicalCharge>::doit(into.GparityMeasurement_u.contraction_type_topological_charge,from.GparityMeasurement_u.contraction_type_topological_charge); break;
	    case CONTRACTION_TYPE_MRES:
	      rpc_deepcopy<ContractionTypeMres>::doit(into.GparityMeasurement_u.contraction_type_mres,from.GparityMeasurement_u.contraction_type_mres); break;
	    case CONTRACTION_TYPE_A2A_BILINEAR:
	      rpc_deepcopy<ContractionTypeA2ABilinear>::doit(into.GparityMeasurement_u.contraction_type_a2a_bilinear,from.GparityMeasurement_u.contraction_type_a2a_bilinear); break;
	    case CONTRACTION_TYPE_WILSON_FLOW:
	      rpc_deepcopy<ContractionTypeWilsonFlow>::doit(into.GparityMeasurement_u.contraction_type_wilson_flow,from.GparityMeasurement_u.contraction_type_wilson_flow); break;
	    case CONTRACTION_TYPE_K_TO_PIPI:
	      rpc_deepcopy<ContractionTypeKtoPiPi>::doit(into.GparityMeasurement_u.contraction_type_k_to_pipi,from.GparityMeasurement_u.contraction_type_k_to_pipi); break;
	  };
}
void GparityMeasurement::deep_copy(GparityMeasurement const &rhs){
	rpc_deepcopy<GparityMeasurement>::doit(*this,rhs);
}
void rpc_print<GparityMeasurement>::doit(GparityMeasurement const &what, const std::string &prefix){
	std::cout << prefix << "{\n";
	std::string spaces(prefix.size(),' ');
	  switch(what.type){
	    case CONTRACTION_TYPE_LL_MESONS:
	      rpc_print<ContractionTypeLLMesons>::doit(what.GparityMeasurement_u.contraction_type_ll_mesons,spaces+" union GparityMeasurement_u.contraction_type_ll_mesons = "); break;
	    case CONTRACTION_TYPE_HL_MESONS:
	      rpc_print<ContractionTypeHLMesons>::doit(what.GparityMeasurement_u.contraction_type_hl_mesons,spaces+" union GparityMeasurement_u.contraction_type_hl_mesons = "); break;
	    case CONTRACTION_TYPE_O_VV_P_AA:
	      rpc_print<ContractionTypeOVVpAA>::doit(what.GparityMeasurement_u.contraction_type_o_vv_p_aa,spaces+" union GparityMeasurement_u.contraction_type_o_vv_p_aa = "); break;
	    case CONTRACTION_TYPE_ALL_BILINEARS:
	      rpc_print<ContractionTypeAllBilinears>::doit(what.GparityMeasurement_u.contraction_type_all_bilinears,spaces+" union GparityMeasurement_u.contraction_type_all_bilinears = "); break;
	    case CONTRACTION_TYPE_ALL_WALLSINK_BILINEARS_SPECIFIC_MOMENTUM:
	      rpc_print<ContractionTypeAllWallSinkBilinearsSpecificMomentum>::doit(what.GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum,spaces+" union GparityMeasurement_u.contraction_type_all_wallsink_bilinears_specific_momentum = "); break;
	    case CONTRACTION_TYPE_FOURIER_PROP:
	      rpc_print<ContractionTypeFourierProp>::doit(what.GparityMeasurement_u.contraction_type_fourier_prop,spaces+" union GparityMeasurement_u.contraction_type_fourier_prop = "); break;
	    case CONTRACTION_TYPE_BILINEAR_VERTEX:
	      rpc_print<ContractionTypeBilinearVertex>::doit(what.GparityMeasurement_u.contraction_type_bilinear_vertex,spaces+" union GparityMeasurement_u.contraction_type_bilinear_vertex = "); break;
	    case CONTRACTION_TYPE_QUADRILINEAR_VERTEX:
	      rpc_print<ContractionTypeQuadrilinearVertex>::doit(what.GparityMeasurement_u.contraction_type_quadrilinear_vertex,spaces+" union GparityMeasurement_u.contraction_type_quadrilinear_vertex = "); break;
	    case CONTRACTION_TYPE_TOPOLOGICAL_CHARGE:
	      rpc_print<ContractionTypeTopologicalCharge>::doit(what.GparityMeasurement_u.contraction_type_topological_charge,spaces+" union GparityMeasurement_u.contraction_type_topological_charge = "); break;
	    case CONTRACTION_TYPE_MRES:
	      rpc_print<ContractionTypeMres>::doit(what.GparityMeasurement_u.contraction_type_mres,spaces+" union GparityMeasurement_u.contraction_type_mres = "); break;
	    case CONTRACTION_TYPE_A2A_BILINEAR:
	      rpc_print<ContractionTypeA2ABilinear>::doit(what.GparityMeasurement_u.contraction_type_a2a_bilinear,spaces+" union GparityMeasurement_u.contraction_type_a2a_bilinear = "); break;
	    case CONTRACTION_TYPE_WILSON_FLOW:
	      rpc_print<ContractionTypeWilsonFlow>::doit(what.GparityMeasurement_u.contraction_type_wilson_flow,spaces+" union GparityMeasurement_u.contraction_type_wilson_flow = "); break;
	    case CONTRACTION_TYPE_K_TO_PIPI:
	      rpc_print<ContractionTypeKtoPiPi>::doit(what.GparityMeasurement_u.contraction_type_k_to_pipi,spaces+" union GparityMeasurement_u.contraction_type_k_to_pipi = "); break;
	  };
	std::cout << spaces << "}\n";
}
void GparityMeasurement::print(const std::string &prefix){
	rpc_print<GparityMeasurement>::doit(*this,prefix);
}
	 bool GparityContractArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityContractArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityContractArg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityContractArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityContractArg (VML *vmls, char *name,GparityContractArg *objp)
{
	 vml_class_begin(vmls,"GparityContractArg",name);
	 if (!vml_array (vmls, "meas", (char **)&objp->meas.meas_val, (u_int *) &objp->meas.meas_len, ~0,
		sizeof (GparityMeasurement), (vmlproc_t) vml_GparityMeasurement))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityContractArg",name);
	return TRUE;
}
void rpc_deepcopy<GparityContractArg>::doit(GparityContractArg &into, GparityContractArg const &from){
	  into.meas.meas_len = from.meas.meas_len;
	  rpc_deepcopy<GparityMeasurement *>::doit(into.meas.meas_val,from.meas.meas_val,from.meas.meas_len);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityContractArg::deep_copy(GparityContractArg const &rhs){
	rpc_deepcopy<GparityContractArg>::doit(*this,rhs);
}
	 bool GparityAMAarg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityAMAarg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityAMAarg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityAMAarg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityAMAarg (VML *vmls, char *name,GparityAMAarg *objp)
{
	 vml_class_begin(vmls,"GparityAMAarg",name);
	 if (!vml_array (vmls, "bilinear_args", (char **)&objp->bilinear_args.bilinear_args_val, (u_int *) &objp->bilinear_args.bilinear_args_len, ~0,
		sizeof (ContractionTypeAllBilinears), (vmlproc_t) vml_ContractionTypeAllBilinears))
		 return FALSE;
	 if (!vml_array (vmls, "exact_solve_timeslices", (char **)&objp->exact_solve_timeslices.exact_solve_timeslices_val, (u_int *) &objp->exact_solve_timeslices.exact_solve_timeslices_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_Float (vmls, "exact_precision", &objp->exact_precision))
		 return FALSE;
	 if (!vml_Float (vmls, "sloppy_precision", &objp->sloppy_precision))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityAMAarg",name);
	return TRUE;
}
void rpc_deepcopy<GparityAMAarg>::doit(GparityAMAarg &into, GparityAMAarg const &from){
	  into.bilinear_args.bilinear_args_len = from.bilinear_args.bilinear_args_len;
	  rpc_deepcopy<ContractionTypeAllBilinears *>::doit(into.bilinear_args.bilinear_args_val,from.bilinear_args.bilinear_args_val,from.bilinear_args.bilinear_args_len);
	  into.exact_solve_timeslices.exact_solve_timeslices_len = from.exact_solve_timeslices.exact_solve_timeslices_len;
	  rpc_deepcopy<int *>::doit(into.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_len);
	  rpc_deepcopy<Float>::doit(into.exact_precision,from.exact_precision);
	  rpc_deepcopy<Float>::doit(into.sloppy_precision,from.sloppy_precision);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityAMAarg::deep_copy(GparityAMAarg const &rhs){
	rpc_deepcopy<GparityAMAarg>::doit(*this,rhs);
}
	 bool GparityAMAbilBKarg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityAMAbilBKarg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityAMAbilBKarg::Vml(VML *vmls,char *instance){
		 if(!vml_GparityAMAbilBKarg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityAMAbilBKarg (VML *vmls, char *name,GparityAMAbilBKarg *objp)
{
	 vml_class_begin(vmls,"GparityAMAbilBKarg",name);
	 if (!vml_array (vmls, "exact_solve_timeslices", (char **)&objp->exact_solve_timeslices.exact_solve_timeslices_val, (u_int *) &objp->exact_solve_timeslices.exact_solve_timeslices_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_Float (vmls, "exact_precision", &objp->exact_precision))
		 return FALSE;
	 if (!vml_Float (vmls, "sloppy_precision", &objp->sloppy_precision))
		 return FALSE;
	 if (!vml_Float (vmls, "ml", &objp->ml))
		 return FALSE;
	 if (!vml_Float (vmls, "mh", &objp->mh))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityAMAbilBKarg",name);
	return TRUE;
}
void rpc_deepcopy<GparityAMAbilBKarg>::doit(GparityAMAbilBKarg &into, GparityAMAbilBKarg const &from){
	  into.exact_solve_timeslices.exact_solve_timeslices_len = from.exact_solve_timeslices.exact_solve_timeslices_len;
	  rpc_deepcopy<int *>::doit(into.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_len);
	  rpc_deepcopy<Float>::doit(into.exact_precision,from.exact_precision);
	  rpc_deepcopy<Float>::doit(into.sloppy_precision,from.sloppy_precision);
	  rpc_deepcopy<Float>::doit(into.ml,from.ml);
	  rpc_deepcopy<Float>::doit(into.mh,from.mh);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityAMAbilBKarg::deep_copy(GparityAMAbilBKarg const &rhs){
	rpc_deepcopy<GparityAMAbilBKarg>::doit(*this,rhs);
}
	 bool GparityAMAarg2::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool GparityAMAarg2::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool GparityAMAarg2::Vml(VML *vmls,char *instance){
		 if(!vml_GparityAMAarg2(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_GparityAMAarg2 (VML *vmls, char *name,GparityAMAarg2 *objp)
{
	 vml_class_begin(vmls,"GparityAMAarg2",name);
	 if (!vml_array (vmls, "exact_solve_timeslices", (char **)&objp->exact_solve_timeslices.exact_solve_timeslices_val, (u_int *) &objp->exact_solve_timeslices.exact_solve_timeslices_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "sloppy_solve_timeslices", (char **)&objp->sloppy_solve_timeslices.sloppy_solve_timeslices_val, (u_int *) &objp->sloppy_solve_timeslices.sloppy_solve_timeslices_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_array (vmls, "bk_tseps", (char **)&objp->bk_tseps.bk_tseps_val, (u_int *) &objp->bk_tseps.bk_tseps_len, ~0,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_Float (vmls, "exact_precision", &objp->exact_precision))
		 return FALSE;
	 if (!vml_Float (vmls, "sloppy_precision", &objp->sloppy_precision))
		 return FALSE;
	 if (!vml_Float (vmls, "ml", &objp->ml))
		 return FALSE;
	 if (!vml_Float (vmls, "mh", &objp->mh))
		 return FALSE;
	 if (!vml_string (vmls, "results_dir", &objp->results_dir, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "config_fmt", &objp->config_fmt, ~0))
		 return FALSE;
	 if (!vml_string (vmls, "rng_fmt", &objp->rng_fmt, ~0))
		 return FALSE;
	 if (!vml_int (vmls, "conf_start", &objp->conf_start))
		 return FALSE;
	 if (!vml_int (vmls, "conf_incr", &objp->conf_incr))
		 return FALSE;
	 if (!vml_int (vmls, "conf_lessthan", &objp->conf_lessthan))
		 return FALSE;
	 if (!vml_FixGaugeArg (vmls, "fix_gauge", &objp->fix_gauge))
		 return FALSE;
	 vml_class_end(vmls,"GparityAMAarg2",name);
	return TRUE;
}
void rpc_deepcopy<GparityAMAarg2>::doit(GparityAMAarg2 &into, GparityAMAarg2 const &from){
	  into.exact_solve_timeslices.exact_solve_timeslices_len = from.exact_solve_timeslices.exact_solve_timeslices_len;
	  rpc_deepcopy<int *>::doit(into.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_val,from.exact_solve_timeslices.exact_solve_timeslices_len);
	  into.sloppy_solve_timeslices.sloppy_solve_timeslices_len = from.sloppy_solve_timeslices.sloppy_solve_timeslices_len;
	  rpc_deepcopy<int *>::doit(into.sloppy_solve_timeslices.sloppy_solve_timeslices_val,from.sloppy_solve_timeslices.sloppy_solve_timeslices_val,from.sloppy_solve_timeslices.sloppy_solve_timeslices_len);
	  into.bk_tseps.bk_tseps_len = from.bk_tseps.bk_tseps_len;
	  rpc_deepcopy<int *>::doit(into.bk_tseps.bk_tseps_val,from.bk_tseps.bk_tseps_val,from.bk_tseps.bk_tseps_len);
	  rpc_deepcopy<Float>::doit(into.exact_precision,from.exact_precision);
	  rpc_deepcopy<Float>::doit(into.sloppy_precision,from.sloppy_precision);
	  rpc_deepcopy<Float>::doit(into.ml,from.ml);
	  rpc_deepcopy<Float>::doit(into.mh,from.mh);
	  rpc_deepcopy<char *>::doit(into.results_dir,from.results_dir,strlen(from.results_dir)+1);
	  rpc_deepcopy<char *>::doit(into.config_fmt,from.config_fmt,strlen(from.config_fmt)+1);
	  rpc_deepcopy<char *>::doit(into.rng_fmt,from.rng_fmt,strlen(from.rng_fmt)+1);
	  rpc_deepcopy<int>::doit(into.conf_start,from.conf_start);
	  rpc_deepcopy<int>::doit(into.conf_incr,from.conf_incr);
	  rpc_deepcopy<int>::doit(into.conf_lessthan,from.conf_lessthan);
	  rpc_deepcopy<FixGaugeArg>::doit(into.fix_gauge,from.fix_gauge);
}
void GparityAMAarg2::deep_copy(GparityAMAarg2 const &rhs){
	rpc_deepcopy<GparityAMAarg2>::doit(*this,rhs);
}
CPS_END_NAMESPACE
