/*
 * Please do not edit this file.
 * It was generated using PAB's VML system.
 */

#include <alg/hdcg_arg.h>
CPS_START_NAMESPACE

bool_t
vml_HDCGcontrol (VML *vmls, char *name,HDCGcontrol *objp)
{
	if (!vml_enum (vmls,name,(enum_t *)objp,HDCGcontrol_map))
		return FALSE;
	return TRUE;
}
struct vml_enum_map HDCGcontrol_map[] = {
	{"HDCGcontrol","HdcgGenerateSubspace",HdcgGenerateSubspace},
	{"HDCGcontrol","HdcgReuseLdop",HdcgReuseLdop},
	{"HDCGcontrol","HdcgRecomputeLdop",HdcgRecomputeLdop},
	{"HDCGcontrol","HdcgRefineSubspace",HdcgRefineSubspace},
	{"HDCGcontrol","HdcgEvlRefineSubspace",HdcgEvlRefineSubspace},
	{ NULL, NULL, 0 }
};
	 bool HdcgArg::Encode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_ENCODE)) return false;
		 if ( !Vml(&vmls,instance) ) return false;
		 vmls.Destroy(); return true;
	 }

	 bool HdcgArg::Decode(char *filename,char *instance){
		 VML vmls;
		 if ( !vmls.Create(filename,VML_DECODE)) return false;
		 if ( !Vml(&vmls,instance)) return false;
		 vmls.Destroy(); return true;
	 }
	 bool HdcgArg::Vml(VML *vmls,char *instance){
		 if(!vml_HdcgArg(vmls,instance,this)) return false;
	 return true;
	}


bool_t
vml_HdcgArg (VML *vmls, char *name,HdcgArg *objp)
{
	 vml_class_begin(vmls,"HdcgArg",name);
	int i;
	 if (!vml_HDCGcontrol (vmls, "Control", &objp->Control))
		 return FALSE;
	 if (!vml_int (vmls, "NumberSubspace", &objp->NumberSubspace))
		 return FALSE;
	 if (!vml_int (vmls, "Ls", &objp->Ls))
		 return FALSE;
	 if (!vml_vector (vmls, "Block", (char *)objp->Block, 5,
		sizeof (int), (vmlproc_t) vml_int))
		 return FALSE;
	 if (!vml_int (vmls, "SubspaceRationalRefine", &objp->SubspaceRationalRefine))
		 return FALSE;
	 if (!vml_double (vmls, "SubspaceRationalRefineLo", &objp->SubspaceRationalRefineLo))
		 return FALSE;
	 if (!vml_double (vmls, "SubspaceRationalRefineResidual", &objp->SubspaceRationalRefineResidual))
		 return FALSE;
	 if (!vml_int (vmls, "SubspaceRationalLs", &objp->SubspaceRationalLs))
		 return FALSE;
	 if (!vml_double (vmls, "SubspaceRationalLo", &objp->SubspaceRationalLo))
		 return FALSE;
	 if (!vml_double (vmls, "SubspaceRationalMass", &objp->SubspaceRationalMass))
		 return FALSE;
	 if (!vml_double (vmls, "SubspaceRationalResidual", &objp->SubspaceRationalResidual))
		 return FALSE;
	 if (!vml_int (vmls, "SubspaceSurfaceDepth", &objp->SubspaceSurfaceDepth))
		 return FALSE;
	 if (!vml_double (vmls, "LittleDopSolverResidualInner", &objp->LittleDopSolverResidualInner))
		 return FALSE;
	 if (!vml_double (vmls, "LittleDopSolverResidualVstart", &objp->LittleDopSolverResidualVstart))
		 return FALSE;
	 if (!vml_double (vmls, "LittleDopSolverResidualSubspace", &objp->LittleDopSolverResidualSubspace))
		 return FALSE;
	 if (!vml_int (vmls, "LittleDopSubspaceRational", &objp->LittleDopSubspaceRational))
		 return FALSE;
	 if (!vml_int (vmls, "LittleDopSolverIterMax", &objp->LittleDopSolverIterMax))
		 return FALSE;
	 if (!vml_int (vmls, "LdopDeflVecs", &objp->LdopDeflVecs))
		 return FALSE;
	 if (!vml_double (vmls, "PreconditionerKrylovResidual", &objp->PreconditionerKrylovResidual))
		 return FALSE;
	 if (!vml_int (vmls, "PreconditionerKrylovIterMax", &objp->PreconditionerKrylovIterMax))
		 return FALSE;
	 if (!vml_double (vmls, "PreconditionerKrylovShift", &objp->PreconditionerKrylovShift))
		 return FALSE;
	 if (!vml_double (vmls, "PcgSingleShift", &objp->PcgSingleShift))
		 return FALSE;
	 if (!vml_int (vmls, "LittleDopSolver", &objp->LittleDopSolver))
		 return FALSE;
	 if (!vml_int (vmls, "Flexible", &objp->Flexible))
		 return FALSE;
	 vml_class_end(vmls,"HdcgArg",name);
	return TRUE;
}
CPS_END_NAMESPACE
